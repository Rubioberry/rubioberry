<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubioberry Gas Futures — Bet on Ethereum Gas Prices (Lone bets refunded)</title>
    <link rel="stylesheet" href="/packages/ui/index.css">
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<video autoplay muted loop playsinline id="bg-video">
    <source src="/BACKGROUND.mp4" type="video/mp4">
</video>

<div class="container">
    <h1>Rubioberry Gas Futures</h1>
    <p>Bet UP or DOWN on Ethereum gas prices — parimutuel markets, settled on TWAP</p>

    <div class="warning" style="margin-bottom:20px; font-size:1.1em; padding:15px;">
        Disclaimer: This is a prediction market involving real ETH. Gamble responsibly. Lone bets (no counter) are refunded.
    </div>

    <div class="success-bar">LIVE ON MAINNET — Berry Edition</div>

    <!-- Contract link for devs/AI audit -->
    <div class="contract-box">
        <strong>Contract (Audit on Etherscan):</strong><br>
        <a href="https://etherscan.io/address/0x122a6a8378705a77b12b3df72c9a92e27679cc9f" target="_blank" style="color:white;font-weight:bold;text-decoration:none;">
            0x122a6a8378705a77b12b3df72c9a92e27679cc9f
        </a>
    </div>

    <div class="button-group">
        <button id="connectButton" class="btn-main">Connect Wallet</button>
    </div>
    <div id="walletStatus" class="success-bar">Wallet not connected (markets visible to all)</div>

    <!-- Create Market — always visible -->
    <div class="calc-box" style="margin:40px 0;">
        <h2>Create New Market</h2>
        <input type="number" id="targetGwei" class="calc-input" placeholder="Target gas price (gwei, e.g. 0.000001)" min="0.000001" step="any">
        <input type="number" id="hoursExpiry" class="calc-input" placeholder="Hours until expiry" min="1" value="24">
        <button id="createMarketBtn" class="btn-main">Create Market</button>
        <div class="note">Decimals allowed (e.g. 0.000001 gwei for ultra-low bets). Use small values for long-term low-gas predictions.</div>
    </div>

    <!-- Live gas tracker -->
    <div class="block-info">
        <h3>Current Gas Price (Base Fee)</h3>
        <div id="currentGas" class="big">Loading...</div>
    </div>

    <!-- Active markets grid -->
    <div id="marketsGrid" class="berry-grid">
        <div class="note">Loading markets...</div>
    </div>

    <div class="nav-footer">
        <a href="/apps/site/index.html" class="nav-btn">Home</a>
        <a href="/apps/site/RBstakingETHonLido.html" class="nav-btn">Stake ETH</a>
        <a href="/apps/site/contact.html" class="nav-btn">Contact</a>
    </div>
</div>

<script>
    const CONTRACT_ADDRESS = "0x122a6a8378705a77b12b3df72c9a92e27679cc9f";
    const CONTRACT_ABI = [
        "function createMarket(uint256 _targetGwei, uint256 _hoursUntilExpiry) external",
        "function betLong(uint256 marketId) external payable",
        "function betShort(uint256 marketId) external payable",
        "function resolveMarket(uint256 marketId) external",
        "function claim(uint256 marketId) external",
        "function markets(uint256) external view returns (uint256 targetGwei, uint256 expiry, uint256 totalLong, uint256 totalShort, bool resolved, bool longWins)",
        "function longBets(uint256, address) external view returns (uint256)",
        "function shortBets(uint256, address) external view returns (uint256)",
        "function getTWAPGwei() external view returns (uint256)"
    ];

    // Public provider for read-only (visible to everyone)
    const publicProvider = new ethers.JsonRpcProvider("https://eth-mainnet.g.alchemy.com/v2/demo"); // Free public Alchemy demo endpoint (rate-limited but fine for reads)
    let publicContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, publicProvider);

    let signer, signedContract, userAddress;
    let loadedMarketIds = new Set();

    const connectButton = document.getElementById("connectButton");
    const walletStatus = document.getElementById("walletStatus");
    const marketsGrid = document.getElementById("marketsGrid");
    const createMarketBtn = document.getElementById("createMarketBtn");

    async function connectWallet() {
        if (!window.ethereum) {
            walletStatus.textContent = "MetaMask not detected!";
            walletStatus.className = "warning";
            return;
        }

        try {
            const provider = new ethers.BrowserProvider(window.ethereum);
            await provider.send("eth_requestAccounts", []);

            signer = await provider.getSigner();
            userAddress = await signer.getAddress();
            signedContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

            const shortAddress = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
            walletStatus.textContent = `Connected: ${shortAddress} (ready to bet/create)`;
            walletStatus.className = "success-bar";
            connectButton.textContent = "Wallet Connected";
            connectButton.disabled = true;

            // Refresh markets with signed contract for user-specific bets display
            loadMarkets(true);
        } catch (error) {
            console.error(error);
            walletStatus.textContent = "Connection failed or rejected";
            walletStatus.className = "warning";
        }
    }

    connectButton.addEventListener("click", connectWallet);

    // Create market (requires connection)
    createMarketBtn.addEventListener("click", async () => {
        if (!signedContract) return alert("Connect wallet to create market");
        // ... (same as before)
        const targetStr = document.getElementById("targetGwei").value.trim();
        const hours = document.getElementById("hoursExpiry").value;

        if (!targetStr || Number(targetStr) <= 0 || !hours || hours <= 0) {
            alert("Enter valid target gwei (e.g. 0.000001) and hours");
            return;
        }

        try {
            const targetWei = ethers.parseUnits(targetStr, 9);
            const tx = await signedContract.createMarket(targetWei, hours);
            walletStatus.textContent = "Creating market... waiting";
            walletStatus.className = "loading";
            await tx.wait();
            walletStatus.textContent = "Market created!";
            walletStatus.className = "success-bar";
            loadMarkets(true); // Refresh with user bets
        } catch (e) {
            console.error(e);
            alert("Create failed: " + (e.message || "Unknown error"));
        }
    });

    async function updateGasPrice() {
        try {
            const block = await publicProvider.getBlock("latest");
            const baseFeeWei = block.baseFeePerGas || 0n;
            const baseFeeGwei = Number(baseFeeWei) / 1e9;
            document.getElementById("currentGas").textContent = baseFeeGwei.toFixed(6) + " gwei";
        } catch (e) {
            document.getElementById("currentGas").textContent = "Error loading gas";
        }
    }

    async function loadMarkets(useSigned = false) {
        const contractToUse = useSigned && signedContract ? signedContract : publicContract;

        try {
            const marketCount = await contractToUse.markets.length;
            const now = Math.floor(Date.now() / 1000);

            let hasActive = false;

            for (let i = 0; i < marketCount; i++) {
                const market = await contractToUse.markets(i);

                if (Number(market.expiry) <= now || market.resolved) continue;

                hasActive = true;

                if (loadedMarketIds.has(i)) continue;

                const pot = Number(market.totalLong) + Number(market.totalShort);
                const longOdds = pot > 0 ? Math.round((Number(market.totalLong) * 100) / pot) : 50;
                const shortOdds = 100 - longOdds;

                // User bets only if signed and address available
                let userLong = 0, userShort = 0, userBetOn = false;
                if (useSigned && userAddress) {
                    userLong = Number(await contractToUse.longBets(i, userAddress));
                    userShort = Number(await contractToUse.shortBets(i, userAddress));
                    userBetOn = (userLong > 0 || userShort > 0);
                }

                const targetGwei = Number(market.targetGwei) / 1e9;
                const expiryDate = new Date(Number(market.expiry) * 1000).toLocaleString();

                const card = document.createElement("div");
                card.className = "berry-card";
                card.id = `market-card-${i}`;
                if (userBetOn) card.style.border = "3px solid #00ffb3";

                card.innerHTML = `
                    <h3>Market #${i} — Target: ${targetGwei.toFixed(6)} gwei</h3>
                    <div class="big">Pot: ${ethers.formatEther(pot)} ETH</div>
                    <div class="big">Odds: LONG ${longOdds}% | SHORT ${shortOdds}%</div>
                    <div>Expires: ${expiryDate}</div>
                    ${userBetOn ? `<div class="success-bar">YOU BET ON THIS MARKET!</div>` : ""}
                    <div class="button-group">
                        <button class="btn-main" onclick="bet(${i}, true)">Bet LONG</button>
                        <button class="btn-sepolia" onclick="bet(${i}, false)">Bet SHORT</button>
                    </div>
                    <div class="note">Your bets: LONG ${ethers.formatEther(userLong)} ETH | SHORT ${ethers.formatEther(userShort)} ETH</div>
                `;

                marketsGrid.appendChild(card);
                loadedMarketIds.add(i);
            }

            if (!hasActive) {
                marketsGrid.innerHTML = "<div class='note'>No active markets right now — create one!</div>";
                loadedMarketIds.clear();
            }
        } catch (e) {
            console.error(e);
            marketsGrid.innerHTML = `<div class="warning">Error loading markets: ${e.message}</div>`;
        }
    }

    async function bet(marketId, isLong) {
        if (!signedContract) return alert("Connect wallet to bet");
        // ... (same prompt/try-catch as before, using signedContract)
        let amountStr = prompt(`How much ETH to bet on ${isLong ? "LONG" : "SHORT"}? (e.g. 0.01)`, "0.01");
        if (!amountStr || parseFloat(amountStr) <= 0) return;

        let value;
        try {
            value = ethers.parseUnits(amountStr.trim(), 18);
        } catch (e) {
            alert("Invalid amount");
            return;
        }

        try {
            const tx = isLong ? await signedContract.betLong(marketId, { value }) : await signedContract.betShort(marketId, { value });
            walletStatus.textContent = "Tx sent... waiting";
            walletStatus.className = "loading";
            await tx.wait();
            walletStatus.textContent = "Bet placed!";
            walletStatus.className = "success-bar";
            loadMarkets(true);
        } catch (e) {
            console.error(e);
            alert("Bet failed: " + (e.message || "Unknown"));
        }
    }

    // Load markets + gas on page load (public)
    loadMarkets();
    updateGasPrice();
    setInterval(() => {
        loadMarkets(!!signedContract); // Use signed if connected
        updateGasPrice();
    }, 60000);

    // Auto-connect if authorized
    if (window.ethereum) {
        window.ethereum.request({ method: "eth_accounts" }).then(accounts => {
            if (accounts.length > 0) connectWallet();
        });
    }
</script>
</body>
</html>
